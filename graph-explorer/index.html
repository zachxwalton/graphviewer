<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Interactive graph explorer — visualize graphs and run path-finding algorithms." />
    <title>Graph Explorer — Zachary Walton</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/10.0.2/standalone/umd/vis-network.min.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              ink: { 950: "#0b0d12", 900: "#0f1219", 850: "#141826", 800: "#1a2030", 700: "#242c40" },
              purpleMid: { 50: "#f4f1ff", 500: "#7c4dff", 600: "#6b38f5", 700: "#5928d8" },
            },
          },
        },
      };
    </script>
    <style>
      #graph-container, #dfs-forest-container, #bfs-tree-container, #dijkstra-tree-container, #topological-sort-container { width: 100%; height: 500px; background: #0f1219; border-radius: 1rem; }
      #topological-sort-section.disabled { opacity: 0.6; pointer-events: none; }
      .vis-network canvas { border-radius: 1rem; }
      .path-edge { stroke: #7c4dff !important; stroke-width: 3 !important; }
      .visited-node { background: rgba(124, 77, 255, 0.4) !important; }
    </style>
  </head>
  <body class="min-h-screen bg-ink-950 text-slate-100 antialiased">
    <header class="sticky top-0 z-40 border-b border-white/5 bg-ink-950/90 backdrop-blur">
      <div class="mx-auto flex max-w-6xl items-center justify-between px-4 py-3 sm:px-6">
        <a href="https://ds320.zwalton.dev/" class="group inline-flex items-center gap-2">
          <span class="inline-flex h-9 w-9 items-center justify-center rounded-xl bg-ink-800 ring-1 ring-white/10 group-hover:ring-purpleMid-500/40">
            <span class="h-2.5 w-2.5 rounded-full bg-purpleMid-500"></span>
          </span>
          <span class="text-sm font-semibold tracking-wide text-white">Graph Algorithm Playground by Zach</span>
        </a>
        <a href="https://github.com/zachxwalton/graphviewer" target="_blank" rel="noreferrer" class="text-sm text-slate-300 hover:text-white">View on GitHub</a>
      </div>
    </header>

    <main class="mx-auto max-w-6xl px-4 py-8 sm:px-6">
      <section class="mb-8">
        <h1 class="text-3xl font-bold text-white">Graph Explorer</h1>
      </section>

      <!-- Graph Generator -->
      <section class="mb-6 rounded-2xl bg-gradient-to-br from-purpleMid-600/10 via-ink-900/60 to-ink-900/60 p-6 ring-2 ring-purpleMid-500/30">
        <h2 class="text-xl font-semibold text-white">Graph Generator</h2>
        <p class="mt-1 text-sm text-slate-300">Customize and generate random graphs. Node colors show distance gradient (purple→pink→red) from universal first node.</p>
        
        <div class="mt-6 grid gap-6 md:grid-cols-2">
          <!-- Number of nodes -->
          <div>
            <label class="block text-sm font-medium text-slate-300">Number of nodes</label>
            <input 
              type="number" 
              id="nodes-input" 
              value="25" 
              min="5" 
              max="1000" 
              class="mt-2 w-full rounded-xl border-0 bg-ink-800 px-4 py-2.5 text-sm text-slate-200 ring-1 ring-white/10 focus:ring-2 focus:ring-purpleMid-500"
            />
          </div>

          <!-- Universal first node -->
          <div>
            <label class="block text-sm font-medium text-slate-300">Universal first node</label>
            <input 
              type="text" 
              id="universal-first-node" 
              value="1" 
              placeholder="e.g. 1" 
              class="mt-2 w-full rounded-xl border-0 bg-ink-800 px-4 py-2.5 text-sm text-slate-200 ring-1 ring-white/10 focus:ring-2 focus:ring-purpleMid-500"
            />
            <p class="mt-1 text-xs text-slate-500">Starting node for DFS, BFS, and Dijkstra trees.</p>
          </div>

          <!-- Directedness slider -->
          <div>
            <div class="flex items-end justify-between">
              <label class="block text-sm font-medium text-slate-300">Directedness</label>
              <span id="directedness-value" class="text-xs text-purpleMid-400">0</span>
            </div>
            <input 
              type="range" 
              id="directedness-slider" 
              min="0" 
              max="10" 
              value="0" 
              class="mt-2 w-full"
            />
            <div class="mt-1 flex justify-between text-xs text-slate-500">
              <span>Undirected</span>
              <span>Directed</span>
            </div>
          </div>

          <!-- Connectedness slider -->
          <div>
            <div class="flex items-end justify-between">
              <label class="block text-sm font-medium text-slate-300">Connectedness</label>
              <span id="connectedness-value" class="text-xs text-purpleMid-400">3</span>
            </div>
            <input 
              type="range" 
              id="connectedness-slider" 
              min="0" 
              max="10" 
              value="3" 
              class="mt-2 w-full"
            />
            <div class="mt-1 flex justify-between text-xs text-slate-500">
              <span>Sparse</span>
              <span>Dense</span>
            </div>
          </div>

          <!-- Cyclicity slider -->
          <div>
            <div class="flex items-end justify-between">
              <label class="block text-sm font-medium text-slate-300">Cyclicity</label>
              <span id="tree-likeness-value" class="text-xs text-purpleMid-400">5</span>
            </div>
            <input 
              type="range" 
              id="tree-likeness-slider" 
              min="0" 
              max="10" 
              value="5" 
              class="mt-2 w-full"
            />
            <div class="mt-1 flex justify-between text-xs text-slate-500">
              <span>Acyclic</span>
              <span>Cyclic</span>
            </div>
          </div>
        </div>

        <button 
          type="button" 
          id="load-sample" 
          class="mt-6 rounded-xl bg-purpleMid-600 px-6 py-3 text-sm font-semibold text-white shadow-lg hover:bg-purpleMid-500"
        >
          Generate Graph
        </button>
        
        <p class="mt-4 text-xs text-slate-400">
          Graphs are generated randomly. For best performance, use under ~1000 nodes.
        </p>
      </section>

      <!-- Graph canvas -->
      <section class="mb-6">
        <div id="graph-container"></div>
        <div class="mt-2 flex flex-wrap items-center justify-between gap-2 text-sm text-slate-400">
          <span id="graph-stats">No graph loaded. Drag to pan, scroll to zoom.</span>
          <div class="flex gap-2">
            <button type="button" id="fit-btn" class="rounded-lg bg-ink-800 px-3 py-1.5 text-slate-300 hover:bg-ink-700 hover:text-white">Fit to screen</button>
            <button type="button" id="reset-btn" class="rounded-lg bg-ink-800 px-3 py-1.5 text-slate-300 hover:bg-ink-700 hover:text-white">Reset layout</button>
          </div>
        </div>
      </section>

      <!-- DFS Tree -->
      <section class="mb-6 rounded-2xl bg-ink-900/60 p-6 ring-1 ring-white/10">
        <h2 class="text-lg font-semibold text-white">DFS Tree</h2>
        <p class="mt-1 text-sm text-slate-300">
          Run DFS from a starting node. Produces a tree of all reachable nodes with parent and descendant relationships.
        </p>
        <p class="mt-1 text-xs text-slate-400">Tiebreaker: When multiple unvisited neighbors exist, explores in reverse order of connections (last connection first).</p>
        <div class="mt-4 flex flex-wrap items-end gap-4">
          <button type="button" id="run-dfs-tree" class="rounded-xl bg-purpleMid-600 px-4 py-2 text-sm font-semibold text-white hover:bg-purpleMid-500">
            Generate DFS Tree
          </button>
          <button type="button" id="dfs-tree-fit-btn" class="rounded-xl bg-ink-800 px-4 py-2 text-sm font-semibold text-slate-200 ring-1 ring-white/10 hover:bg-ink-700 hover:text-white">
            Fit tree
          </button>
          <label class="flex cursor-pointer items-center gap-2 rounded-xl bg-ink-800 px-4 py-2 ring-1 ring-white/10 hover:ring-purpleMid-500/40">
            <input type="checkbox" id="dfs-show-prepost" class="rounded text-purpleMid-500 focus:ring-purpleMid-500" />
            <span class="text-sm text-slate-200">Show pre/post order</span>
          </label>
        </div>
        <div id="dfs-forest-progress" class="mt-4 hidden rounded-xl bg-ink-850/60 p-4">
          <div class="mb-2 flex justify-between text-sm text-slate-300">
            <span id="dfs-progress-label">Running DFS...</span>
            <span id="dfs-progress-pct">0%</span>
          </div>
          <div class="h-2 w-full overflow-hidden rounded-full bg-ink-800">
            <div id="dfs-progress-bar" class="h-full bg-purpleMid-500 transition-all duration-150" style="width: 0%"></div>
          </div>
        </div>
        <div id="dfs-forest-container" class="mt-4"></div>
        <div id="dfs-forest-result" class="mt-4 max-h-48 overflow-auto rounded-xl bg-ink-850/60 p-4 font-mono text-xs text-slate-200"></div>
      </section>

      <!-- BFS Tree -->
      <section class="mb-6 rounded-2xl bg-ink-900/60 p-6 ring-1 ring-white/10">
        <h2 class="text-lg font-semibold text-white">BFS Tree</h2>
        <p class="mt-1 text-sm text-slate-300">
          Run BFS from a starting node. Produces a tree showing distance from first node.
        </p>
        <p class="mt-1 text-xs text-slate-400">Tiebreaker: When multiple unvisited neighbors exist, explores in order of connections (first connection first).</p>
        <div class="mt-4 flex flex-wrap items-end gap-4">
          <button type="button" id="run-bfs-tree" class="rounded-xl bg-purpleMid-600 px-4 py-2 text-sm font-semibold text-white hover:bg-purpleMid-500">
            Generate BFS Tree
          </button>
          <button type="button" id="bfs-tree-fit-btn" class="rounded-xl bg-ink-800 px-4 py-2 text-sm font-semibold text-slate-200 ring-1 ring-white/10 hover:bg-ink-700 hover:text-white">
            Fit tree
          </button>
          <label class="flex cursor-pointer items-center gap-2 rounded-xl bg-ink-800 px-4 py-2 ring-1 ring-white/10 hover:ring-purpleMid-500/40">
            <input type="checkbox" id="bfs-show-distance" class="rounded text-purpleMid-500 focus:ring-purpleMid-500" />
            <span class="text-sm text-slate-200">Show distance</span>
          </label>
        </div>
        <div id="bfs-tree-container" class="mt-4"></div>
        <div id="bfs-tree-result" class="mt-4 max-h-48 overflow-auto rounded-xl bg-ink-850/60 p-4 font-mono text-xs text-slate-200"></div>
      </section>

      <!-- Dijkstra Tree -->
      <section class="mb-6 rounded-2xl bg-ink-900/60 p-6 ring-1 ring-white/10">
        <h2 class="text-lg font-semibold text-white">Dijkstra Tree</h2>
        <p class="mt-1 text-sm text-slate-300">
          Run Dijkstra from a starting node. Produces a shortest-path tree showing distances (cost) from source.
        </p>
        <p class="mt-1 text-xs text-slate-400">Tiebreaker: When multiple nodes have the same distance, processes in order of connections (first connection first).</p>
        <div class="mt-4 flex flex-wrap items-end gap-4">
          <button type="button" id="run-dijkstra-tree" class="rounded-xl bg-purpleMid-600 px-4 py-2 text-sm font-semibold text-white hover:bg-purpleMid-500">
            Generate Dijkstra Tree
          </button>
          <button type="button" id="dijkstra-tree-fit-btn" class="rounded-xl bg-ink-800 px-4 py-2 text-sm font-semibold text-slate-200 ring-1 ring-white/10 hover:bg-ink-700 hover:text-white">
            Fit tree
          </button>
          <label class="flex cursor-pointer items-center gap-2 rounded-xl bg-ink-800 px-4 py-2 ring-1 ring-white/10 hover:ring-purpleMid-500/40">
            <input type="checkbox" id="dijkstra-show-distance" class="rounded text-purpleMid-500 focus:ring-purpleMid-500" />
            <span class="text-sm text-slate-200">Show distance</span>
          </label>
        </div>
        <div id="dijkstra-tree-container" class="mt-4"></div>
        <div id="dijkstra-tree-result" class="mt-4 max-h-48 overflow-auto rounded-xl bg-ink-850/60 p-4 font-mono text-xs text-slate-200"></div>
      </section>

      <!-- Shortest path -->
      <section class="rounded-2xl bg-ink-900/60 p-6 ring-1 ring-white/10">
        <h2 class="text-lg font-semibold text-white">Shortest Path</h2>
        <p class="mt-1 text-sm text-slate-300">Select two nodes and run an algorithm to find the shortest path between them.</p>
        <div class="mt-4 flex flex-wrap items-end gap-4">
          <div>
            <label class="block text-xs text-slate-400">Source node</label>
            <input type="text" id="source-input" placeholder="e.g. 0" class="mt-1 w-32 rounded-lg bg-ink-800 px-3 py-2 text-sm text-slate-200 ring-1 ring-white/10" />
          </div>
          <div>
            <label class="block text-xs text-slate-400">Target node</label>
            <input type="text" id="target-input" placeholder="e.g. 10" class="mt-1 w-32 rounded-lg bg-ink-800 px-3 py-2 text-sm text-slate-200 ring-1 ring-white/10" />
          </div>
          <label class="flex cursor-pointer items-center gap-2 rounded-xl bg-ink-800 px-4 py-2 ring-1 ring-white/10 hover:ring-purpleMid-500/40">
            <input type="checkbox" id="advanced-algorithms-toggle" class="rounded text-purpleMid-500 focus:ring-purpleMid-500" />
            <span class="text-sm text-slate-200">Advanced algorithms</span>
          </label>
          <div class="flex flex-wrap gap-2">
            <button type="button" id="run-bfs" class="rounded-xl bg-purpleMid-600 px-4 py-2 text-sm font-semibold text-white hover:bg-purpleMid-500">BFS</button>
            <button type="button" id="run-dfs" class="rounded-xl bg-ink-800 px-4 py-2 text-sm font-semibold text-slate-200 ring-1 ring-white/10 hover:bg-ink-700">DFS</button>
            <button type="button" id="run-dijkstra" class="rounded-xl bg-ink-800 px-4 py-2 text-sm font-semibold text-slate-200 ring-1 ring-white/10 hover:bg-ink-700">Dijkstra</button>
            <div id="advanced-algorithm-buttons" class="hidden flex gap-2">
              <button type="button" id="run-astar" class="rounded-xl bg-ink-800 px-4 py-2 text-sm font-semibold text-slate-200 ring-1 ring-white/10 hover:bg-ink-700">A*</button>
              <button type="button" id="run-bellman-ford" class="rounded-xl bg-ink-800 px-4 py-2 text-sm font-semibold text-slate-200 ring-1 ring-white/10 hover:bg-ink-700">Bellman-Ford</button>
            </div>
          </div>
        </div>
        <div id="path-result" class="mt-4 rounded-xl bg-ink-850/60 p-4 text-sm text-slate-200"></div>
      </section>

      <!-- Topological Sort -->
      <section id="topological-sort-section" class="mt-6 rounded-2xl bg-ink-900/60 p-6 ring-1 ring-white/10 disabled">
        <h2 class="text-lg font-semibold text-white">Topological Sort</h2>
        <p class="mt-1 text-sm text-slate-300">
          Linear ordering of vertices such that for every directed edge (u, v), u comes before v. Non-unique, there may be many answers—this just displays one. Use the verifier to check your answers.
        </p>
        <div id="topological-sort-disabled" class="mt-4 rounded-xl bg-ink-800/80 p-4 text-center text-sm text-slate-400">
          Graph must be acyclical and directional to generate a topological sort!
        </div>
        <div id="topological-sort-enabled" class="mt-4 hidden">
          <div class="flex flex-wrap items-end gap-4">
            <button type="button" id="run-topological-sort" class="rounded-xl bg-purpleMid-600 px-4 py-2 text-sm font-semibold text-white hover:bg-purpleMid-500">
              Generate Topological Sort
            </button>
            <div>
              <label class="block text-xs text-slate-400">Verify order (e.g. 1, 3, 2, 5, 4)</label>
              <input type="text" id="topological-sort-verify-input" placeholder="e.g. 1, 3, 2, 5, 4" class="mt-1 w-64 rounded-lg bg-ink-800 px-3 py-2 text-sm text-slate-200 ring-1 ring-white/10" />
            </div>
            <button type="button" id="verify-topological-sort" class="rounded-xl bg-ink-800 px-4 py-2 text-sm font-semibold text-slate-200 ring-1 ring-white/10 hover:bg-ink-700">
              Verify non-unique topological sort
            </button>
          </div>
          <div id="topological-sort-verify-result" class="mt-2 rounded-xl bg-ink-850/60 p-4 text-sm text-slate-200 hidden"></div>
          <div id="topological-sort-order" class="mt-4 rounded-xl bg-ink-850/60 p-4 font-mono text-sm text-slate-200"></div>
          <div id="topological-sort-container" class="mt-4"></div>
        </div>
      </section>
    </main>

    <script>
      (function () {
        function generateSampleGraph(n, connectedness, treeLikeness, directedness) {
          const nodes = Array.from({ length: n }, (_, i) => String(i));
          const edgeSet = new Set();
          const parent = Array.from({ length: n }, (_, i) => i);

          const find = (x) => {
            if (parent[x] !== x) parent[x] = find(parent[x]);
            return parent[x];
          };
          const union = (x, y) => {
            const px = find(x);
            const py = find(y);
            if (px !== py) {
              parent[px] = py;
              return true;
            }
            return false;
          };

          const addEdge = (u, v) => {
            const key = u < v ? `${u}\t${v}` : `${v}\t${u}`;
            if (!edgeSet.has(key)) {
              edgeSet.add(key);
              union(u, v);
              return true;
            }
            return false;
          };

          // Tree-likedness: at 10/10 we build actual trees (root splits into 0-5 children).
          // At 0 we build a cyclic chain + random edges. In between we blend.
          const useTreeStructure = treeLikeness >= 6;

          if (useTreeStructure) {
            // Number of roots: 1 at 10/10, more as tree-likedness drops
            const rootCount = treeLikeness >= 10 ? 1 : Math.max(1, Math.min(Math.ceil(n / 20), Math.ceil(10 - treeLikeness)));
            const roots = [];
            const shuffled = Array.from({ length: n }, (_, i) => i);
            for (let i = shuffled.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            for (let i = 0; i < rootCount; i++) roots.push(shuffled[i]);

            const inTree = new Set(roots);
            const childrenCount = new Map();
            roots.forEach((r) => childrenCount.set(r, 0));
            const queue = [...roots];
            const available = shuffled.filter((x) => !inTree.has(x));
            let availIdx = 0;

            while (queue.length > 0 && availIdx < available.length) {
              const p = queue.shift();
              const maxChildren = 5;
              const numChildren = Math.min(
                Math.floor(Math.random() * (maxChildren + 1)),
                maxChildren - (childrenCount.get(p) || 0),
                available.length - availIdx
              );
              for (let c = 0; c < numChildren; c++) {
                const child = available[availIdx++];
                addEdge(p, child);
                inTree.add(child);
                childrenCount.set(child, 0);
                childrenCount.set(p, (childrenCount.get(p) || 0) + 1);
                queue.push(child);
              }
            }

            // Connect any leftover nodes to tree nodes that have < 5 children
            while (availIdx < available.length) {
              const child = available[availIdx++];
              const candidates = [...inTree].filter((x) => (childrenCount.get(x) || 0) < 5);
              const p = candidates.length > 0
                ? candidates[Math.floor(Math.random() * candidates.length)]
                : roots[Math.floor(Math.random() * roots.length)];
              addEdge(p, child);
              childrenCount.set(p, (childrenCount.get(p) || 0) + 1);
            }
          } else {
            // Low tree-likedness: chain base + random edges (cyclic)
            for (let i = 0; i < n - 1; i++) {
              addEdge(i, i + 1);
            }
          }

          // Add extra edges based on connectedness (cross-tree, or cycle-forming when tree-likedness is low)
          const baseEdges = edgeSet.size;
          const maxEdges = Math.floor((n * (n - 1)) / 2);
          const targetEdges = Math.floor(baseEdges + (connectedness / 10) * Math.min(n * 4, maxEdges - baseEdges));
          const skipCycleProbability = treeLikeness / 10;

          let added = 0;
          const maxAttempts = targetEdges * 10;
          let attempts = 0;

          while (added < targetEdges - baseEdges && attempts < maxAttempts) {
            const u = Math.floor(Math.random() * n);
            const v = Math.floor(Math.random() * n);
            attempts++;
            if (u === v) continue;
            const key = u < v ? `${u}\t${v}` : `${v}\t${u}`;
            if (edgeSet.has(key)) continue;

            const wouldCreateCycle = find(u) === find(v);
            if (wouldCreateCycle && Math.random() < skipCycleProbability) continue;

            edgeSet.add(key);
            if (!wouldCreateCycle) union(u, v);
            added++;
          }

          const directednessRatio = directedness / 10;
          const edges = Array.from(edgeSet).map((s) => {
            const [from, to] = s.split('\t');
            return {
              from: String(from),
              to: String(to),
              directed: Math.random() < directednessRatio,
            };
          });
          return { nodes, edges };
        }

        let graphData = null;
        let network = null;
        let forestNetwork = null;
        let bfsNetwork = null;
        let dijkstraNetwork = null;
        let lastForest = null;
        let lastBfsTree = null;
        let lastDijkstraTree = null;
        let topoNetwork = null;

        function buildGraph(nodes, edges, distanceMap, maxDistance, firstNode) {
          const nodeList = nodes.map((id) => {
            const dist = distanceMap ? distanceMap.get(id) : 0;
            const max = maxDistance ?? 0;
            const bg = distanceMap ? getColorForDistance(dist, max) : '#4a5568';
            const border = distanceMap ? getColorForDistance(dist, max) : '#718096';
            const isFirst = firstNode && String(id) === String(firstNode);
            return {
              id,
              label: String(id),
              color: { background: isFirst ? '#fbbf24' : bg, border: isFirst ? '#ffffff' : border },
              borderWidth: isFirst ? 2 : 1,
            };
          });
          const edgeList = edges.map((e, i) => ({
            id: i,
            from: e.from,
            to: e.to,
            arrows: e.directed ? 'to' : undefined,
          }));
          return { nodes: nodeList, edges: edgeList };
        }

        function buildAdjacency(nodes, edges) {
          const adj = new Map();
          for (const n of nodes) adj.set(n, []);
          for (const e of edges) {
            adj.get(e.from).push(e.to);
            if (!e.directed && e.from !== e.to) adj.get(e.to).push(e.from);
          }
          return adj;
        }

        function buildAdjacencyBidirectional(nodes, edges) {
          const adj = new Map();
          for (const n of nodes) adj.set(n, []);
          for (const e of edges) {
            adj.get(e.from).push(e.to);
            if (e.from !== e.to) adj.get(e.to).push(e.from);
          }
          return adj;
        }

        function buildDirectedAdjacency(nodes, edges) {
          const adj = new Map();
          for (const n of nodes) adj.set(n, []);
          for (const e of edges) {
            if (e.directed) adj.get(e.from).push(e.to);
          }
          return adj;
        }

        function computeDistancesFrom(nodes, edges, start, ignoreDirection) {
          const adj = ignoreDirection ? buildAdjacencyBidirectional(nodes, edges) : buildAdjacency(nodes, edges);
          const dist = new Map();
          nodes.forEach((n) => dist.set(n, Infinity));
          dist.set(start, 0);
          const queue = [start];
          while (queue.length > 0) {
            const u = queue.shift();
            const d = dist.get(u);
            for (const v of adj.get(u) || []) {
              if (dist.get(v) === Infinity) {
                dist.set(v, d + 1);
                queue.push(v);
              }
            }
          }
          return dist;
        }

        function getColorForDistance(distance, maxDistance) {
          const gray = '#4a5568';
          if (distance === Infinity || distance === undefined) return gray;
          const purple = { r: 124, g: 77, b: 255 };
          const pink = { r: 236, g: 72, b: 153 };
          const red = { r: 239, g: 68, b: 68 };
          const lerp = (c1, c2, t) => {
            const r = Math.round(c1.r + (c2.r - c1.r) * t);
            const g = Math.round(c1.g + (c2.g - c1.g) * t);
            const b = Math.round(c1.b + (c2.b - c1.b) * t);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
          };
          if (maxDistance === 0) return lerp(purple, red, 0);
          const x = Math.min(1, distance / maxDistance);
          const t = (Math.exp(2 * x) - 1) / (Math.exp(2) - 1);
          if (t <= 0.5) return lerp(purple, pink, t * 2);
          return lerp(pink, red, (t - 0.5) * 2);
        }

        function renderGraph(data) {
          const container = document.getElementById('graph-container');
          const options = {
            nodes: {
              shape: 'dot',
              size: 12,
              font: { color: '#e2e8f0', size: 10 },
            },
            edges: {
              color: { color: '#64748b' },
              width: 1,
            },
            physics: {
              enabled: true,
              forceAtlas2Based: {
                gravitationalConstant: -50,
                centralGravity: 0.01,
                springLength: 150,
                springConstant: 0.08,
              },
              solver: 'forceAtlas2Based',
              stabilization: { iterations: 150 },
            },
            interaction: {
              zoomView: true,
              dragView: true,
              hover: true,
            },
          };

          if (network) network.destroy();
          network = new vis.Network(container, data, options);

          network.on('stabilizationIterationsDone', () => {
            network.setOptions({ physics: false });
          });

          document.getElementById('graph-stats').textContent =
            `${data.nodes.length} nodes, ${data.edges.length} edges. Drag to pan, scroll to zoom.`;
        }

        function updateGraph() {
          if (!graphData) return;
          const firstNode = document.getElementById('universal-first-node').value.trim();
          const directedness = parseInt(document.getElementById('directedness-slider')?.value ?? 0, 10);
          const cyclicity = parseInt(document.getElementById('tree-likeness-slider')?.value ?? 0, 10);
          const ignoreDirection = (directedness === 10) && (cyclicity === 0);
          const distanceMap = graphData.nodes.includes(firstNode)
            ? computeDistancesFrom(graphData.nodes, graphData.edges, firstNode, ignoreDirection)
            : null;
          const maxDistance = distanceMap
            ? Math.max(...[...distanceMap.values()].filter((d) => d !== Infinity), 0)
            : 0;
          graphData.distanceMap = distanceMap;
          graphData.maxDistance = maxDistance;
          const visData = buildGraph(graphData.nodes, graphData.edges, distanceMap, maxDistance, firstNode);
          renderGraph(visData);
        }

        function loadGraph(nodes, edges) {
          graphData = { nodes, edges };
          updateGraph();
        }

        function highlightPath(path, visited) {
          if (!network || !graphData) return;
          const nodes = graphData.nodes;
          const dist = graphData.distanceMap;
          const maxDist = graphData.maxDistance || 0;
          const firstNode = document.getElementById('universal-first-node')?.value?.trim();
          const edgeSet = new Set();
          for (let i = 0; i < path.length - 1; i++) {
            edgeSet.add(`${path[i]}-${path[i + 1]}`);
            edgeSet.add(`${path[i + 1]}-${path[i]}`);
          }

          const nodeUpdates = nodes.map((n) => {
            const isFirst = firstNode && String(n) === String(firstNode);
            const baseColor = dist ? getColorForDistance(dist.get(n) ?? Infinity, maxDist) : '#4a5568';
            const bg = isFirst ? '#fbbf24' : (path.includes(n) ? '#7c4dff' : visited.has(n) ? 'rgba(124, 77, 255, 0.5)' : baseColor);
            const border = isFirst ? '#ffffff' : (path.includes(n) ? '#9d79ff' : visited.has(n) ? '#9d79ff' : baseColor);
            return { id: n, color: { background: bg, border }, ...(isFirst && { borderWidth: 2 }) };
          });
          network.body.data.nodes.update(nodeUpdates);

          const edgeUpdates = graphData.edges.map((e, i) => {
            const key1 = `${e.from}-${e.to}`;
            const key2 = `${e.to}-${e.from}`;
            const onPath = edgeSet.has(key1) || edgeSet.has(key2);
            return { id: i, color: onPath ? { color: '#7c4dff' } : { color: '#64748b' }, width: onPath ? 3 : 1 };
          });
          network.body.data.edges.update(edgeUpdates);
        }

        function resetHighlight() {
          if (!network || !graphData) return;
          const dist = graphData.distanceMap;
          const maxDist = graphData.maxDistance || 0;
          const firstNode = document.getElementById('universal-first-node')?.value?.trim();
          const nodeUpdates = graphData.nodes.map((n) => {
            const isFirst = firstNode && String(n) === String(firstNode);
            const c = isFirst ? '#fbbf24' : (dist ? getColorForDistance(dist.get(n) ?? Infinity, maxDist) : '#4a5568');
            const border = isFirst ? '#ffffff' : c;
            return { id: n, color: { background: c, border }, ...(isFirst && { borderWidth: 2 }) };
          });
          network.body.data.nodes.update(nodeUpdates);
          const edgeUpdates = graphData.edges.map((e, i) => ({
            id: i,
            color: { color: '#64748b' },
            width: 1,
          }));
          network.body.data.edges.update(edgeUpdates);
        }

        function dfs(adj, start, end) {
          const visited = new Set();
          const stack = [[start]];
          visited.add(start);

          while (stack.length > 0) {
            const path = stack.pop();
            const node = path[path.length - 1];
            if (node === end) return { path, visited };

            for (const neighbor of adj.get(node) || []) {
              if (!visited.has(neighbor)) {
                visited.add(neighbor);
                stack.push([...path, neighbor]);
              }
            }
          }
          return { path: null, visited };
        }

        function bfs(adj, start, end) {
          const visited = new Set();
          const queue = [[start]];
          visited.add(start);

          while (queue.length > 0) {
            const path = queue.shift();
            const node = path[path.length - 1];
            if (node === end) return { path, visited };

            for (const neighbor of adj.get(node) || []) {
              if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push([...path, neighbor]);
              }
            }
          }
          return { path: null, visited };
        }

        function dijkstra(adj, start, end) {
          const dist = new Map();
          const prev = new Map();
          const visited = new Set();
          const pq = [[0, start]];
          dist.set(start, 0);

          while (pq.length > 0) {
            pq.sort((a, b) => a[0] - b[0]);
            const [d, node] = pq.shift();
            if (visited.has(node)) continue;
            visited.add(node);
            if (node === end) break;

            for (const neighbor of adj.get(node) || []) {
              const alt = d + 1;
              if ((!dist.has(neighbor) || alt < dist.get(neighbor)) && !visited.has(neighbor)) {
                dist.set(neighbor, alt);
                prev.set(neighbor, node);
                pq.push([alt, neighbor]);
              }
            }
          }

          const path = [];
          let cur = end;
          while (cur != null) {
            path.unshift(cur);
            cur = prev.get(cur);
          }
          return path[0] === start ? { path, visited } : { path: null, visited };
        }

        function astar(adj, start, end) {
          const heuristic = (n) => {
            const a = parseFloat(n);
            const b = parseFloat(end);
            return Number.isFinite(a) && Number.isFinite(b) ? Math.abs(a - b) : 0;
          };
          const dist = new Map();
          const prev = new Map();
          const visited = new Set();
          const openSet = [[0 + heuristic(start), 0, start]];
          dist.set(start, 0);

          while (openSet.length > 0) {
            openSet.sort((a, b) => a[0] - b[0]);
            const [f, d, node] = openSet.shift();
            if (visited.has(node)) continue;
            visited.add(node);
            if (node === end) break;

            for (const neighbor of adj.get(node) || []) {
              const alt = d + 1;
              if (!dist.has(neighbor) || alt < dist.get(neighbor)) {
                dist.set(neighbor, alt);
                prev.set(neighbor, node);
                openSet.push([alt + heuristic(neighbor), alt, neighbor]);
              }
            }
          }

          const path = [];
          let cur = end;
          while (cur != null) {
            path.unshift(cur);
            cur = prev.get(cur);
          }
          return path[0] === start ? { path, visited } : { path: null, visited };
        }

        function bellmanFord(adj, start, end, nodes) {
          const dist = new Map();
          const prev = new Map();
          nodes.forEach((n) => dist.set(n, Infinity));
          dist.set(start, 0);

          for (let i = 0; i < nodes.length - 1; i++) {
            for (const u of nodes) {
              const d = dist.get(u);
              if (d === Infinity) continue;
              for (const v of adj.get(u) || []) {
                const alt = d + 1;
                if (alt < dist.get(v)) {
                  dist.set(v, alt);
                  prev.set(v, u);
                }
              }
            }
          }

          const visited = new Set();
          const stack = [start];
          visited.add(start);
          while (stack.length > 0) {
            const u = stack.pop();
            for (const v of adj.get(u) || []) {
              if (!visited.has(v)) {
                visited.add(v);
                stack.push(v);
              }
            }
          }

          const path = [];
          let cur = end;
          while (cur != null) {
            path.unshift(cur);
            cur = prev.get(cur);
          }
          return path[0] === start ? { path, visited } : { path: null, visited };
        }

        function topologicalSort(adj, nodes) {
          const visited = new Set();
          const stack = [];
          function visit(u) {
            if (visited.has(u)) return;
            visited.add(u);
            for (const v of adj.get(u) || []) visit(v);
            stack.push(u);
          }
          for (const n of nodes) visit(n);
          return stack.reverse();
        }

        function verifyTopologicalSort(order, nodes, edges) {
          const directedEdges = edges.filter((e) => e.directed);
          const nodeSet = new Set(nodes.map(String));
          const orderStrs = order.map((n) => String(n).trim()).filter(Boolean);
          const uniqueOrder = new Set(orderStrs);
          if (uniqueOrder.size !== orderStrs.length) {
            return { valid: false, message: 'Invalid: order contains duplicate nodes.' };
          }
          const missing = nodes.filter((n) => !uniqueOrder.has(String(n)));
          const extra = orderStrs.filter((n) => !nodeSet.has(n));
          if (missing.length > 0) return { valid: false, message: `Invalid: missing nodes: ${missing.join(', ')}.` };
          if (extra.length > 0) return { valid: false, message: `Invalid: unknown nodes: ${extra.join(', ')}.` };
          const indexOf = new Map();
          orderStrs.forEach((n, i) => indexOf.set(n, i));
          for (const e of directedEdges) {
            const u = String(e.from);
            const v = String(e.to);
            const iu = indexOf.get(u);
            const iv = indexOf.get(v);
            if (iu === undefined || iv === undefined) {
              const missingNode = iu === undefined ? u : v;
              return { valid: false, message: `Invalid: node "${missingNode}" not in order.` };
            }
            if (iu >= iv) {
              return { valid: false, message: `Invalid: edge (${u}, ${v}) violated — ${u} must come before ${v}.` };
            }
          }
          return { valid: true, message: 'Valid topological sort!' };
        }

        function bfsTree(adj, start) {
          const visited = new Set();
          const parent = new Map();
          const children = new Map();
          const distance = new Map();
          const visitOrder = [];

          const queue = [start];
          visited.add(start);
          parent.set(start, null);
          children.set(start, []);
          distance.set(start, 0);
          visitOrder.push(start);

          while (queue.length > 0) {
            const u = queue.shift();
            const d = distance.get(u);
            for (const v of adj.get(u) || []) {
              if (!visited.has(v)) {
                visited.add(v);
                parent.set(v, u);
                children.set(v, []);
                children.get(u).push(v);
                distance.set(v, d + 1);
                visitOrder.push(v);
                queue.push(v);
              }
            }
          }
          return { root: start, visitOrder, parent, children, distance };
        }

        function dijkstraTree(adj, start) {
          const dist = new Map();
          const prev = new Map();
          const visited = new Set();
          const visitOrder = [];
          const pq = [[0, start]];
          dist.set(start, 0);

          while (pq.length > 0) {
            pq.sort((a, b) => a[0] - b[0]);
            const [d, node] = pq.shift();
            if (visited.has(node)) continue;
            visited.add(node);
            visitOrder.push(node);

            for (const neighbor of adj.get(node) || []) {
              const alt = d + 1;
              if (!dist.has(neighbor) || alt < dist.get(neighbor)) {
                dist.set(neighbor, alt);
                prev.set(neighbor, node);
                pq.push([alt, neighbor]);
              }
            }
          }

          const children = new Map();
          visitOrder.forEach((n) => children.set(n, []));
          for (const [child, p] of prev) {
            if (p != null) children.get(p).push(child);
          }
          const distance = new Map();
          visitOrder.forEach((n) => distance.set(n, dist.get(n)));
          return { root: start, visitOrder, parent: prev, children, distance };
        }

        function dfsForest(adj, start) {
          const visited = new Set();
          const parent = new Map();
          const children = new Map();
          const visitOrder = [];
          const roots = [start];

          const stack = [start];
          visited.add(start);
          parent.set(start, null);
          children.set(start, []);
          visitOrder.push(start);

          while (stack.length > 0) {
            const u = stack.pop();
            for (const v of adj.get(u) || []) {
              if (!visited.has(v)) {
                visited.add(v);
                parent.set(v, u);
                children.set(v, []);
                children.get(u).push(v);
                visitOrder.push(v);
                stack.push(v);
              }
            }
          }
          return { roots, visitOrder, parent, children };
        }

        async function dfsForestWithProgress(adj, start, totalNodes, onProgress) {
          const visited = new Set();
          const parent = new Map();
          const children = new Map();
          const visitOrder = [];
          const preOrder = new Map();
          const postOrder = new Map();
          const roots = [start];

          let counter = 1;
          let iter = 0;

          const yieldControl = () => new Promise((r) => setTimeout(r, 0));

          const stack = [{ node: start, phase: 'enter' }];
          visited.add(start);
          parent.set(start, null);
          children.set(start, []);

          while (stack.length > 0) {
            const { node: u, phase } = stack.pop();

            if (phase === 'enter') {
              preOrder.set(u, counter++);
              visitOrder.push(u);
              stack.push({ node: u, phase: 'exit' });

              const neighbors = adj.get(u) || [];
              for (let i = neighbors.length - 1; i >= 0; i--) {
                const v = neighbors[i];
                if (!visited.has(v)) {
                  visited.add(v);
                  parent.set(v, u);
                  children.set(v, []);
                  children.get(u).push(v);
                  stack.push({ node: v, phase: 'enter' });
                }
              }
            } else if (phase === 'exit') {
              postOrder.set(u, counter++);
            }

            iter++;
            if (iter % 50 === 0 || stack.length === 0) {
              const pct = Math.min(100, Math.round((visited.size / totalNodes) * 100));
              onProgress(visited.size, pct);
              await yieldControl();
            }
          }

          onProgress(visited.size, 100);
          return { roots, visitOrder, parent, children, preOrder, postOrder };
        }

        function buildForestGraphData(forest, showPrePost, distanceMap, maxDistance) {
          const roots = new Set(forest.roots);
          const nodeList = forest.visitOrder.map((id) => {
            const pre = forest.preOrder.get(id);
            const post = forest.postOrder.get(id);
            const desc = forest.children.get(id) || [];
            const isRoot = roots.has(id);
            const label = showPrePost ? `${id}\npre:${pre} post:${post}` : String(id);
            const title = showPrePost
              ? (isRoot
                ? `Root: ${id}\npre-order: ${pre}\npost-order: ${post}\ndescendants: [${desc.join(', ')}]`
                : `Node: ${id}\nparent: ${forest.parent.get(id)}\npre-order: ${pre}\npost-order: ${post}\ndescendants: [${desc.join(', ')}]`)
              : (isRoot
                ? `Root: ${id}\ndescendants: [${desc.join(', ')}]`
                : `Node: ${id}\nparent: ${forest.parent.get(id)}\ndescendants: [${desc.join(', ')}]`);
            const c = distanceMap ? getColorForDistance(distanceMap.get(id) ?? Infinity, maxDistance || 0) : (isRoot ? '#7c4dff' : '#4a5568');
            return {
              id,
              label,
              title,
              color: { background: isRoot ? '#fbbf24' : c, border: isRoot ? '#ffffff' : c },
              borderWidth: isRoot ? 2 : 1,
              font: { multi: true, size: 11 },
            };
          });
          const edgeList = [];
          let edgeId = 0;
          for (const [child, parent] of forest.parent) {
            if (parent != null) {
              edgeList.push({ id: edgeId++, from: parent, to: child, arrows: 'to' });
            }
          }
          return { nodes: nodeList, edges: edgeList };
        }

        function renderForestGraph(data) {
          const container = document.getElementById('dfs-forest-container');
          if (!container) {
            console.error('DFS forest container not found');
            return;
          }
          if (forestNetwork) {
            forestNetwork.destroy();
            forestNetwork = null;
          }
          
          console.log('Rendering forest with data:', data);
          
          if (!data.nodes || data.nodes.length === 0) {
            container.innerHTML = '<div class="text-slate-400 text-sm p-4">No nodes to display</div>';
            return;
          }

          const visData = {
            nodes: new vis.DataSet(data.nodes),
            edges: new vis.DataSet(data.edges),
          };

          const useHierarchical = data.edges.length > 0;
          const options = {
            nodes: {
              shape: 'dot',
              size: 16,
              font: { color: '#e2e8f0', size: 11 },
            },
            edges: {
              color: { color: '#64748b' },
              width: 2,
              arrows: { to: { enabled: true, scaleFactor: 0.5 } },
            },
            layout: useHierarchical
              ? {
                  hierarchical: {
                    enabled: true,
                    direction: 'UD',
                    sortMethod: 'directed',
                    levelSeparation: 100,
                    nodeSpacing: 150,
                  },
                }
              : {
                  randomSeed: 42,
                },
            physics: {
              enabled: !useHierarchical,
              stabilization: { iterations: 200 },
              forceAtlas2Based: {
                gravitationalConstant: -50,
                centralGravity: 0.01,
                springLength: 150,
              },
            },
            interaction: {
              zoomView: true,
              dragView: true,
              hover: true,
            },
          };

          try {
            forestNetwork = new vis.Network(container, visData, options);
            console.log('Forest network created successfully');
            
            if (!useHierarchical) {
              forestNetwork.once('stabilizationIterationsDone', () => {
                forestNetwork.setOptions({ physics: { enabled: false } });
              });
            }
            
            setTimeout(() => {
              if (forestNetwork) forestNetwork.fit({ animation: { duration: 500 } });
            }, 100);
          } catch (err) {
            console.error('Error creating forest network:', err);
            container.innerHTML = `<div class="text-red-400 text-sm p-4">Error rendering graph: ${err.message}</div>`;
          }
        }

        function buildBfsTreeGraphData(bfsTree, showDistance, distanceMap, maxDistance) {
          const root = bfsTree.root;
          const nodeList = bfsTree.visitOrder.map((id) => {
            const dist = bfsTree.distance.get(id);
            const desc = bfsTree.children.get(id) || [];
            const isRoot = id === root;
            const label = showDistance ? `${id}\ndist:${dist}` : String(id);
            const title = showDistance
              ? (isRoot
                ? `Root: ${id}\ndistance: ${dist}\ndescendants: [${desc.join(', ')}]`
                : `Node: ${id}\nparent: ${bfsTree.parent.get(id)}\ndistance: ${dist}\ndescendants: [${desc.join(', ')}]`)
              : (isRoot
                ? `Root: ${id}\ndescendants: [${desc.join(', ')}]`
                : `Node: ${id}\nparent: ${bfsTree.parent.get(id)}\ndescendants: [${desc.join(', ')}]`);
            const c = distanceMap ? getColorForDistance(distanceMap.get(id) ?? Infinity, maxDistance || 0) : (isRoot ? '#7c4dff' : '#4a5568');
            return {
              id,
              label,
              title,
              color: { background: isRoot ? '#fbbf24' : c, border: isRoot ? '#ffffff' : c },
              borderWidth: isRoot ? 2 : 1,
              font: { multi: true, size: 11 },
            };
          });
          const edgeList = [];
          let edgeId = 0;
          for (const [child, p] of bfsTree.parent) {
            if (p != null) {
              edgeList.push({ id: edgeId++, from: p, to: child, arrows: 'to' });
            }
          }
          return { nodes: nodeList, edges: edgeList };
        }

        function renderBfsTreeGraph(data) {
          const container = document.getElementById('bfs-tree-container');
          if (!container) return;
          if (bfsNetwork) {
            bfsNetwork.destroy();
            bfsNetwork = null;
          }
          if (!data.nodes || data.nodes.length === 0) {
            container.innerHTML = '<div class="text-slate-400 text-sm p-4">No nodes to display</div>';
            return;
          }
          const visData = {
            nodes: new vis.DataSet(data.nodes),
            edges: new vis.DataSet(data.edges),
          };
          const useHierarchical = data.edges.length > 0;
          const options = {
            nodes: { shape: 'dot', size: 16, font: { color: '#e2e8f0', size: 11 } },
            edges: { color: { color: '#64748b' }, width: 2, arrows: { to: { enabled: true, scaleFactor: 0.5 } } },
            layout: useHierarchical
              ? { hierarchical: { enabled: true, direction: 'UD', sortMethod: 'directed', levelSeparation: 100, nodeSpacing: 150 } }
              : { randomSeed: 42 },
            physics: { enabled: !useHierarchical, stabilization: { iterations: 200 } },
            interaction: { zoomView: true, dragView: true, hover: true },
          };
          try {
            bfsNetwork = new vis.Network(container, visData, options);
            if (!useHierarchical) {
              bfsNetwork.once('stabilizationIterationsDone', () => bfsNetwork.setOptions({ physics: { enabled: false } }));
            }
            setTimeout(() => { if (bfsNetwork) bfsNetwork.fit({ animation: { duration: 500 } }); }, 100);
          } catch (err) {
            container.innerHTML = `<div class="text-red-400 text-sm p-4">Error: ${err.message}</div>`;
          }
        }

        function buildDijkstraTreeGraphData(tree, showDistance, distanceMap, maxDistance) {
          return buildBfsTreeGraphData(tree, showDistance, distanceMap, maxDistance);
        }

        function renderDijkstraTreeGraph(data) {
          const container = document.getElementById('dijkstra-tree-container');
          if (!container) return;
          if (dijkstraNetwork) {
            dijkstraNetwork.destroy();
            dijkstraNetwork = null;
          }
          if (!data.nodes || data.nodes.length === 0) {
            container.innerHTML = '<div class="text-slate-400 text-sm p-4">No nodes to display</div>';
            return;
          }
          const visData = {
            nodes: new vis.DataSet(data.nodes),
            edges: new vis.DataSet(data.edges),
          };
          const useHierarchical = data.edges.length > 0;
          const options = {
            nodes: { shape: 'dot', size: 16, font: { color: '#e2e8f0', size: 11 } },
            edges: { color: { color: '#64748b' }, width: 2, arrows: { to: { enabled: true, scaleFactor: 0.5 } } },
            layout: useHierarchical
              ? { hierarchical: { enabled: true, direction: 'UD', sortMethod: 'directed', levelSeparation: 100, nodeSpacing: 150 } }
              : { randomSeed: 42 },
            physics: { enabled: !useHierarchical, stabilization: { iterations: 200 } },
            interaction: { zoomView: true, dragView: true, hover: true },
          };
          try {
            dijkstraNetwork = new vis.Network(container, visData, options);
            if (!useHierarchical) {
              dijkstraNetwork.once('stabilizationIterationsDone', () => dijkstraNetwork.setOptions({ physics: { enabled: false } }));
            }
            setTimeout(() => { if (dijkstraNetwork) dijkstraNetwork.fit({ animation: { duration: 500 } }); }, 100);
          } catch (err) {
            container.innerHTML = `<div class="text-red-400 text-sm p-4">Error: ${err.message}</div>`;
          }
        }

        function formatDijkstraTreeOutput(tree, showDistance) {
          return formatBfsTreeOutput(tree, showDistance);
        }

        function formatBfsTreeOutput(bfsTree, showDistance) {
          const lines = [];
          lines.push(`Visit order (level by level): ${bfsTree.visitOrder.join(' → ')}`);
          lines.push('');
          lines.push(`Root: ${bfsTree.root}`);
          const treeNodes = bfsTree.visitOrder;
          treeNodes.forEach((n) => {
            const p = bfsTree.parent.get(n);
            const desc = bfsTree.children.get(n) || [];
            const dist = bfsTree.distance.get(n);
            const nodeLine = showDistance
              ? `  ${n}: parent=${p ?? 'null'}, distance=${dist}, descendants=[${desc.join(', ')}]`
              : `  ${n}: parent=${p ?? 'null'}, descendants=[${desc.join(', ')}]`;
            lines.push(nodeLine);
          });
          return lines.join('\n');
        }

        function formatDfsForestOutput(forest, showPrePost) {
          const lines = [];
          lines.push(`Visit order: ${forest.visitOrder.join(' → ')}`);
          lines.push('');
          forest.roots.forEach((root, i) => {
            lines.push(`Tree ${i + 1} (root: ${root}):`);
            const inTree = new Set();
            const collect = (n) => {
              inTree.add(n);
              for (const c of forest.children.get(n) || []) collect(c);
            };
            collect(root);
            const treeNodes = forest.visitOrder.filter((n) => inTree.has(n));
            treeNodes.forEach((n) => {
              const p = forest.parent.get(n);
              const desc = forest.children.get(n) || [];
              const pre = forest.preOrder.get(n);
              const post = forest.postOrder.get(n);
              const nodeLine = showPrePost
                ? `  ${n}: parent=${p ?? 'null'}, pre=${pre}, post=${post}, descendants=[${desc.join(', ')}]`
                : `  ${n}: parent=${p ?? 'null'}, descendants=[${desc.join(', ')}]`;
              lines.push(nodeLine);
            });
            lines.push('');
          });
          return lines.join('\n');
        }

        function runAlgorithm(algoName, algoFn) {
          if (!graphData) {
            document.getElementById('path-result').textContent = 'Load a graph first.';
            return;
          }
          const source = document.getElementById('source-input').value.trim();
          const target = document.getElementById('target-input').value.trim();
          if (!source || !target) {
            document.getElementById('path-result').textContent = 'Enter source and target nodes.';
            return;
          }
          if (!graphData.nodes.includes(source) || !graphData.nodes.includes(target)) {
            document.getElementById('path-result').textContent = `Vertices must be in the graph. Available: ${graphData.nodes.slice(0, 20).join(', ')}${graphData.nodes.length > 20 ? '...' : ''}`;
            return;
          }

          resetHighlight();
          const adj = buildAdjacency(graphData.nodes, graphData.edges);
          const { path, visited } = algoFn(adj, source, target);

          const resultEl = document.getElementById('path-result');
          if (path) {
            resultEl.textContent = `${algoName}: Path found (length ${path.length - 1}): ${path.join(' → ')}`;
            highlightPath(path, visited);
            network.focus(path[Math.floor(path.length / 2)], { scale: 1.2, animation: true });
          } else {
            resultEl.textContent = `${algoName}: No path exists between ${source} and ${target}.`;
            highlightPath([], visited);
          }
        }

        const connectednessSlider = document.getElementById('connectedness-slider');
        const connectednessValue = document.getElementById('connectedness-value');
        const treeLikenessSlider = document.getElementById('tree-likeness-slider');
        const treeLikenessValue = document.getElementById('tree-likeness-value');

        connectednessSlider.addEventListener('input', (e) => {
          connectednessValue.textContent = e.target.value;
        });

        treeLikenessSlider.addEventListener('input', (e) => {
          treeLikenessValue.textContent = e.target.value;
          updateTopologicalSortSectionVisibility();
        });
        treeLikenessSlider.addEventListener('change', () => {
          if (graphData) {
            updateGraph();
            const firstNode = document.getElementById('universal-first-node').value.trim();
            if (firstNode && graphData.nodes.includes(firstNode)) {
              runDfsForest();
              runBfsTree();
              runDijkstraTree();
            }
          }
        });

        const directednessSlider = document.getElementById('directedness-slider');
        const directednessValue = document.getElementById('directedness-value');

        directednessSlider.addEventListener('input', (e) => {
          directednessValue.textContent = e.target.value;
          updateTopologicalSortSectionVisibility();
        });
        directednessSlider.addEventListener('change', () => {
          if (graphData) {
            updateGraph();
            const firstNode = document.getElementById('universal-first-node').value.trim();
            if (firstNode && graphData.nodes.includes(firstNode)) {
              runDfsForest();
              runBfsTree();
              runDijkstraTree();
            }
          }
        });

        function updateTopologicalSortSectionVisibility() {
          const section = document.getElementById('topological-sort-section');
          const disabledDiv = document.getElementById('topological-sort-disabled');
          const enabledDiv = document.getElementById('topological-sort-enabled');
          const directed = parseInt(directednessSlider.value, 10) === 10;
          const acyclic = parseInt(treeLikenessSlider.value, 10) === 0;
          const isEnabled = directed && acyclic;
          if (isEnabled) {
            section.classList.remove('disabled');
            disabledDiv.classList.add('hidden');
            enabledDiv.classList.remove('hidden');
          } else {
            section.classList.add('disabled');
            disabledDiv.classList.remove('hidden');
            enabledDiv.classList.add('hidden');
          }
        }

        document.getElementById('load-sample').addEventListener('click', () => {
          const n = parseInt(document.getElementById('nodes-input').value, 10);
          const connectedness = parseInt(connectednessSlider.value, 10);
          const cyclicSlider = parseInt(treeLikenessSlider.value, 10);
          const treeLikeness = 10 - cyclicSlider;
          const directedness = parseInt(directednessSlider.value, 10);
          
          if (!n || n < 2 || n > 10000) {
            alert('Please enter a valid number of nodes (2-10000)');
            return;
          }
          
          const { nodes, edges } = generateSampleGraph(n, connectedness, treeLikeness, directedness);
          loadGraph(nodes, edges);
          runDfsForest();
          runBfsTree();
          runDijkstraTree();
          runTopologicalSort();
        });

        document.getElementById('universal-first-node').addEventListener('change', () => {
          if (!graphData) return;
          updateGraph();
          const firstNode = document.getElementById('universal-first-node').value.trim();
          if (firstNode && graphData.nodes.includes(firstNode)) {
            runDfsForest();
            runBfsTree();
            runDijkstraTree();
          }
        });

        document.getElementById('fit-btn').addEventListener('click', () => {
          if (network) network.fit({ animation: true });
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
          resetHighlight();
          if (graphData) updateGraph();
        });

        function updateAdvancedAlgorithmsVisibility() {
          const toggle = document.getElementById('advanced-algorithms-toggle');
          const advancedBtns = document.getElementById('advanced-algorithm-buttons');
          if (toggle.checked) {
            advancedBtns.classList.remove('hidden');
            advancedBtns.classList.add('flex');
          } else {
            advancedBtns.classList.add('hidden');
            advancedBtns.classList.remove('flex');
          }
        }

        document.getElementById('advanced-algorithms-toggle').addEventListener('change', updateAdvancedAlgorithmsVisibility);
        updateAdvancedAlgorithmsVisibility();

        document.getElementById('run-bfs').addEventListener('click', () =>
          runAlgorithm('BFS', (adj, s, t) => bfs(adj, s, t))
        );
        document.getElementById('run-dfs').addEventListener('click', () =>
          runAlgorithm('DFS', (adj, s, t) => dfs(adj, s, t))
        );
        document.getElementById('run-dijkstra').addEventListener('click', () =>
          runAlgorithm('Dijkstra', (adj, s, t) => dijkstra(adj, s, t))
        );
        document.getElementById('run-astar').addEventListener('click', () =>
          runAlgorithm('A*', (adj, s, t) => astar(adj, s, t))
        );
        document.getElementById('run-bellman-ford').addEventListener('click', () =>
          runAlgorithm('Bellman-Ford', (adj, s, t) => bellmanFord(adj, s, t, [...adj.keys()]))
        );

        async function runDfsForest() {
          if (!graphData) {
            document.getElementById('dfs-forest-result').textContent = 'Load a graph first.';
            return;
          }
          const startNode = document.getElementById('universal-first-node').value.trim();
          if (!startNode) {
            document.getElementById('dfs-forest-result').textContent = 'Enter a start node.';
            return;
          }
          if (!graphData.nodes.includes(startNode)) {
            document.getElementById('dfs-forest-result').textContent = `Start node "${startNode}" not in graph. Available: ${graphData.nodes.slice(0, 20).join(', ')}${graphData.nodes.length > 20 ? '...' : ''}`;
            return;
          }
          resetHighlight();
          const progressEl = document.getElementById('dfs-forest-progress');
          const progressBar = document.getElementById('dfs-progress-bar');
          const progressLabel = document.getElementById('dfs-progress-label');
          const progressPct = document.getElementById('dfs-progress-pct');
          progressEl.classList.remove('hidden');
          progressBar.style.width = '0%';
          progressPct.textContent = '0%';
          progressLabel.textContent = 'Running DFS...';

          const adj = buildAdjacency(graphData.nodes, graphData.edges);
          const totalNodes = graphData.nodes.length;

          const forest = await dfsForestWithProgress(adj, startNode, totalNodes, (visited, pct) => {
            progressBar.style.width = pct + '%';
            progressPct.textContent = pct + '%';
            progressLabel.textContent = `Visited ${visited} nodes...`;
          });

          progressEl.classList.add('hidden');
          lastForest = forest;
          const showPrePost = document.getElementById('dfs-show-prepost').checked;
          const forestData = buildForestGraphData(forest, showPrePost, graphData.distanceMap, graphData.maxDistance);
          renderForestGraph(forestData);
          document.getElementById('dfs-forest-result').textContent = formatDfsForestOutput(forest, showPrePost);
        }

        function refreshForestDisplay() {
          if (!lastForest) return;
          const showPrePost = document.getElementById('dfs-show-prepost').checked;
          const forestData = buildForestGraphData(lastForest, showPrePost, graphData?.distanceMap, graphData?.maxDistance);
          renderForestGraph(forestData);
          document.getElementById('dfs-forest-result').textContent = formatDfsForestOutput(lastForest, showPrePost);
        }

        document.getElementById('run-dfs-tree').addEventListener('click', runDfsForest);
        document.getElementById('dfs-show-prepost').addEventListener('change', refreshForestDisplay);

        function runBfsTree() {
          if (!graphData) {
            document.getElementById('bfs-tree-result').textContent = 'Load a graph first.';
            return;
          }
          const startNode = document.getElementById('universal-first-node').value.trim();
          if (!startNode) {
            document.getElementById('bfs-tree-result').textContent = 'Enter a start node.';
            return;
          }
          if (!graphData.nodes.includes(startNode)) {
            document.getElementById('bfs-tree-result').textContent = `Start node "${startNode}" not in graph. Available: ${graphData.nodes.slice(0, 20).join(', ')}${graphData.nodes.length > 20 ? '...' : ''}`;
            return;
          }
          resetHighlight();
          const adj = buildAdjacency(graphData.nodes, graphData.edges);
          const tree = bfsTree(adj, startNode);
          lastBfsTree = tree;
          const showDistance = document.getElementById('bfs-show-distance').checked;
          const treeData = buildBfsTreeGraphData(tree, showDistance, graphData.distanceMap, graphData.maxDistance);
          renderBfsTreeGraph(treeData);
          document.getElementById('bfs-tree-result').textContent = formatBfsTreeOutput(tree, showDistance);
        }

        function refreshBfsTreeDisplay() {
          if (!lastBfsTree) return;
          const showDistance = document.getElementById('bfs-show-distance').checked;
          const treeData = buildBfsTreeGraphData(lastBfsTree, showDistance, graphData?.distanceMap, graphData?.maxDistance);
          renderBfsTreeGraph(treeData);
          document.getElementById('bfs-tree-result').textContent = formatBfsTreeOutput(lastBfsTree, showDistance);
        }

        document.getElementById('run-bfs-tree').addEventListener('click', runBfsTree);
        document.getElementById('bfs-show-distance').addEventListener('change', refreshBfsTreeDisplay);
        document.getElementById('bfs-tree-fit-btn').addEventListener('click', () => {
          if (bfsNetwork) bfsNetwork.fit({ animation: true });
        });

        function runDijkstraTree() {
          if (!graphData) {
            document.getElementById('dijkstra-tree-result').textContent = 'Load a graph first.';
            return;
          }
          const startNode = document.getElementById('universal-first-node').value.trim();
          if (!startNode) {
            document.getElementById('dijkstra-tree-result').textContent = 'Enter a start node.';
            return;
          }
          if (!graphData.nodes.includes(startNode)) {
            document.getElementById('dijkstra-tree-result').textContent = `Start node "${startNode}" not in graph. Available: ${graphData.nodes.slice(0, 20).join(', ')}${graphData.nodes.length > 20 ? '...' : ''}`;
            return;
          }
          resetHighlight();
          const adj = buildAdjacency(graphData.nodes, graphData.edges);
          const tree = dijkstraTree(adj, startNode);
          lastDijkstraTree = tree;
          const showDistance = document.getElementById('dijkstra-show-distance').checked;
          const treeData = buildDijkstraTreeGraphData(tree, showDistance, graphData.distanceMap, graphData.maxDistance);
          renderDijkstraTreeGraph(treeData);
          document.getElementById('dijkstra-tree-result').textContent = formatDijkstraTreeOutput(tree, showDistance);
        }

        function refreshDijkstraTreeDisplay() {
          if (!lastDijkstraTree) return;
          const showDistance = document.getElementById('dijkstra-show-distance').checked;
          const treeData = buildDijkstraTreeGraphData(lastDijkstraTree, showDistance, graphData?.distanceMap, graphData?.maxDistance);
          renderDijkstraTreeGraph(treeData);
          document.getElementById('dijkstra-tree-result').textContent = formatDijkstraTreeOutput(lastDijkstraTree, showDistance);
        }

        document.getElementById('run-dijkstra-tree').addEventListener('click', runDijkstraTree);
        document.getElementById('dijkstra-show-distance').addEventListener('change', refreshDijkstraTreeDisplay);
        document.getElementById('dijkstra-tree-fit-btn').addEventListener('click', () => {
          if (dijkstraNetwork) dijkstraNetwork.fit({ animation: true });
        });

        function runTopologicalSort() {
          if (!graphData) {
            document.getElementById('topological-sort-order').textContent = 'Load a graph first.';
            return;
          }
          const adj = buildDirectedAdjacency(graphData.nodes, graphData.edges);
          const order = topologicalSort(adj, graphData.nodes);
          document.getElementById('topological-sort-order').textContent = `Order: ${order.join(' → ')}`;
          const nodeList = order.map((id, i) => ({
            id,
            label: `${id}\n(${i + 1})`,
            x: i * 120,
            y: 250,
            fixed: true,
            color: { background: '#4a5568', border: '#718096' },
            font: { color: '#e2e8f0', size: 11 },
          }));
          const edgeList = graphData.edges
            .filter((e) => e.directed)
            .map((e, i) => ({ id: i, from: e.from, to: e.to, arrows: 'to' }));
          const container = document.getElementById('topological-sort-container');
          if (topoNetwork) {
            topoNetwork.destroy();
            topoNetwork = null;
          }
          if (nodeList.length > 0) {
            try {
              topoNetwork = new vis.Network(container, {
                nodes: new vis.DataSet(nodeList),
                edges: new vis.DataSet(edgeList),
              }, {
                nodes: { shape: 'dot', size: 16 },
                edges: { color: { color: '#64748b' }, width: 2, arrows: { to: { enabled: true, scaleFactor: 0.5 } } },
                physics: { enabled: false },
                interaction: { zoomView: true, dragView: true },
              });
              topoNetwork.fit({ animation: { duration: 500 } });
            } catch (err) {
              container.innerHTML = `<div class="text-red-400 text-sm p-4">Error: ${err.message}</div>`;
            }
          } else {
            container.innerHTML = '<div class="text-slate-400 text-sm p-4">No nodes</div>';
          }
        }

        document.getElementById('run-topological-sort').addEventListener('click', runTopologicalSort);

        function runVerifyTopologicalSort() {
          const resultEl = document.getElementById('topological-sort-verify-result');
          resultEl.classList.remove('hidden');
          if (!graphData) {
            resultEl.textContent = 'Load a graph first.';
            resultEl.className = 'mt-2 rounded-xl bg-ink-850/60 p-4 text-sm text-slate-200';
            return;
          }
          const input = document.getElementById('topological-sort-verify-input').value.trim();
          if (!input) {
            resultEl.textContent = 'Enter an order to verify.';
            resultEl.className = 'mt-2 rounded-xl bg-ink-850/60 p-4 text-sm text-slate-200';
            return;
          }
          const order = input.split(/[\s,→]+/).map((s) => s.trim()).filter(Boolean);
          const result = verifyTopologicalSort(order, graphData.nodes, graphData.edges);
          resultEl.textContent = result.message;
          resultEl.className = result.valid
            ? 'mt-2 rounded-xl bg-ink-850/60 p-4 text-sm text-green-400'
            : 'mt-2 rounded-xl bg-ink-850/60 p-4 text-sm text-red-400';
        }

        document.getElementById('verify-topological-sort').addEventListener('click', runVerifyTopologicalSort);

        document.getElementById('dfs-tree-fit-btn').addEventListener('click', () => {
          if (forestNetwork) forestNetwork.fit({ animation: true });
        });

        // Startup: generate default graph and run DFS, BFS, Dijkstra trees, topological sort
        (function init() {
          updateTopologicalSortSectionVisibility();
          const { nodes, edges } = generateSampleGraph(25, 3, 5, 0);
          loadGraph(nodes, edges);
          runDfsForest();
          runBfsTree();
          runDijkstraTree();
          runTopologicalSort();
        })();
      })();
    </script>
  </body>
</html>
